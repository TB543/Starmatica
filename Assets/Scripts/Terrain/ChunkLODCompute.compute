// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// struct for chunk data
struct ChunkData
{
    float3 origin;
    float3 xAxis;
    float3 yAxis;
    int index; // not used in this shader, used by the chunk manager to identify chunks
    int isLeaf; // 0 is false 1 is true
    int canMergeChildren; // 0 for false 1 for true
};

// variables to be passed to the shader
int mode; // 0 is for merge checks, 1 is for split checks.
int numChunks;
float3 cameraPosition;
float3 chunkGlobalPosition;
float radius;

// buffers for passing data to/from the shader
RWStructuredBuffer<ChunkData> chunks;
RWStructuredBuffer<int> result;
RWByteAddressBuffer count; // atomic index count

// constants used for LOD calculations
static const float maxDetailThreshold = 1000; // chunks under this distance will be rendered at max LOD
static const float maxChunkSize = 200; // the maximum size of a chunk
static const float LODThreshold = .4; // relative screen size for chunks for when to split/merge
static const float falloffPower = 3; // higher values = LOD decreases faster
static const float falloffDistance = 10000; // how wide the falloff zone is

/*
* Projects a point on the unit cube to a point on the sphere using the
* cube-to-sphere projection algorithm. This ensures that the vertices are
* evenly distributed across the surface of the sphere.
*
* @param p The point on the unit cube to be projected.
* @return The projected point on the sphere.
*/
float3 project(float3 p)
{
    float x2 = p.x * p.x;
    float y2 = p.y * p.y;
    float z2 = p.z * p.z;
    
    float x = p.x * sqrt(1 - (y2 / 2) - (z2 / 2) + ((y2 * z2) / 3));
    float y = p.y * sqrt(1 - (z2 / 2) - (x2 / 2) + ((z2 * x2) / 3));
    float z = p.z * sqrt(1 - (x2 / 2) - (y2 / 2) + ((x2 * y2) / 3));
            
    return normalize(float3(x, y, z));
}

/*
* finds all the chunks that need a LOD update
*/
[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // bounds check
    if (id.x >= (uint) numChunks)
        return;
    
    // calculates the screen ratio of the chunk based on the camera distance
    float3 center = project(chunks[id.x].origin + (.5 * chunks[id.x].xAxis) + (.5 * chunks[id.x].yAxis)) * radius;
    float dist = length(cameraPosition - (chunkGlobalPosition + center));
    float size = length(chunks[id.x].xAxis) * radius;
    float ratio = size / dist;
    
    // applies falloff formula
    float blend = saturate((dist - maxDetailThreshold) / (falloffDistance));
    ratio = pow(abs(ratio), lerp(1.0, falloffPower, blend));
    
    // merge check
    if (mode == 0 && dist >= maxDetailThreshold && chunks[id.x].isLeaf == 0 && chunks[id.x].canMergeChildren == 1 && ratio < LODThreshold) {
        uint index;
        count.InterlockedAdd(0, 1, index);
        result[index] = chunks[id.x].index;
    }

    // split check
    else if (mode == 1 && chunks[id.x].isLeaf == 1 && (ratio >= LODThreshold || dist < maxDetailThreshold) && size > maxChunkSize) {
        uint index;
        count.InterlockedAdd(0, 1, index);
        result[index] = chunks[id.x].index;
    }
}
