using UnityEngine;

/*
 * todo in init method dont create new game objects, just calculate the number of chunks needed and return
 * then in planet class create submeshes based on the number of chunks needed
 * in each chunk store the submesh index 
 * 
 * thiss should significantly reduce the number of game objects created and improve performance
 */

public class Chunk : MonoBehaviour
{
    // fields set in the Unity editor
    [SerializeField] int maxSize;
    [SerializeField] GameObject chunkPrefab;
    [SerializeField] ComputeShader terrainShader;

    // LOD distance settings: LOD5 to LOD1 where LOD1 is the furthest away
    [Header("LOD Thresholds")]
    [SerializeField] float LOD1Threshold;
    [SerializeField] float LOD2Threshold;
    [SerializeField] float LOD3Threshold;
    [SerializeField] float LOD4Threshold;

    // LOD chunk resolution settings: LOD5 to LOD1 where LOD1 is the lowest detail
    [Header("LOD Details")]
    [SerializeField] int LOD1Detail;
    [SerializeField] int LOD2Detail;
    [SerializeField] int LOD3Detail;
    [SerializeField] int LOD4Detail;

    // field variables for this chunk
    private Vector3 center;
    private Vector3 origin;
    private Vector3 xAxis;
    private Vector3 yAxis;
    private Planet planet;
    private Mesh mesh;
    private int detail;

    /*
     * Constructor for Chunk.
     * Initializes the chunk with the given parameters.
     *
     * @param origin The origin point of the chunk.
     * @param xAxis The x-axis direction of the chunk.
     * @param yAxis The y-axis direction of the chunk.
     * @param planet The planet this chunk belongs to.
     */
    public void init(Vector3 origin, Vector3 xAxis, Vector3 yAxis, Planet planet)
    {
        // intializes the chunk with the given parameters
        center = project(origin + (.5f * xAxis) + (.5f * yAxis)) * planet.radius;
        this.origin = origin;
        this.xAxis = xAxis;
        this.yAxis = yAxis;
        this.planet = planet;

        // creates the mesh and splits the chunk if needed
        mesh = gameObject.GetComponent<MeshFilter>().mesh;
        split(origin, xAxis, yAxis, planet);
    }

    /*
     * Splits the chunk if it is too large and creates smaller chunks.
     * 
     * @param origin The origin point of the chunk.
     * @param xAxis The x-axis direction of the chunk.
     * @param yAxis The y-axis direction of the chunk.
     * @param planet The planet this chunk belongs to.
     */
    private void split(Vector3 origin, Vector3 xAxis, Vector3 yAxis, Planet planet)
    {
        // checks if the chunk exceeds the maximum size
        if (xAxis.magnitude * planet.radius <= maxSize)
            return;

        // splits the axis to 4 smaller chunks
        Vector3 splitXAxis = xAxis / 2f;
        Vector3 splitYAxis = yAxis / 2f;

        // creates a new chunk objects
        foreach (Vector3 newChunk in new Vector3[] { splitXAxis, splitYAxis, splitXAxis + splitYAxis }) {
            GameObject chunkObj = Instantiate(chunkPrefab, planet.transform);
            chunkObj.GetComponent<Chunk>().init(origin + newChunk, splitXAxis, splitYAxis, planet);
        }

        // shrinks the current chunk
        center = project(origin + (.5f * splitXAxis) + (.5f * splitYAxis)) * planet.radius;
        this.xAxis = splitXAxis;
        this.yAxis = splitYAxis;
        split(origin, splitXAxis, splitYAxis, planet);
    }

    /*
     * Generates the chunk mesh using the detail level
     * The chunk is generated by creating vertices and triangles
     */
    private void generate()
    {
        // creates variables to store the mesh data
        Vector3[] vertices = new Vector3[detail * detail];
        int[] triangles = new int[(detail - 1) * (detail - 1) * 6];
        ComputeBuffer vertexBuffer = new ComputeBuffer(detail * detail, sizeof(float) * 3);
        ComputeBuffer triangleBuffer = new ComputeBuffer((detail - 1) * (detail - 1) * 6, sizeof(int));
        vertexBuffer.SetData(vertices);
        triangleBuffer.SetData(triangles);

        // starts the compute shader and returns the computed points
        setShaderParameters(vertexBuffer, triangleBuffer);
        int groups = Mathf.CeilToInt(detail / 8f);
        terrainShader.Dispatch(0, groups, groups, 1);
        vertexBuffer.GetData(vertices);
        triangleBuffer.GetData(triangles);

        // sets the mesh data
        mesh.Clear();
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        vertexBuffer.Release();
        triangleBuffer.Release();
        mesh.RecalculateNormals();
    }

    /*
    * sets the shader parameters for the chunk 
    * 
    * @param vertexBuffer The compute buffer containing the vertices.
    * @param triangleBuffer The compute buffer containing the triangles.
    */
    private void setShaderParameters(ComputeBuffer vertexBuffer, ComputeBuffer triangleBuffer)
    {
        terrainShader.SetBuffer(0, "points", vertexBuffer);
        terrainShader.SetBuffer(0, "triangles", triangleBuffer);
        terrainShader.SetVector("origin", origin);
        terrainShader.SetVector("xAxis", xAxis);
        terrainShader.SetVector("yAxis", yAxis);
        terrainShader.SetFloat("radius", planet.radius);
        terrainShader.SetInt("detail", detail);
        terrainShader.SetInt("seed", planet.seed);
    }

    /*
     * Projects a point on the unit cube to a point on the sphere using the
     * cube-to-sphere projection algorithm. This ensures that the vertices are
     * evenly distributed across the surface of the sphere.
     *
     * @param point The point on the unit cube to be projected.
     * @return The projected point on the sphere.
     */
    private Vector3 project(Vector3 point)
    {
        float x2 = point.x * point.x;
        float y2 = point.y * point.y;
        float z2 = point.z * point.z;
        float x = point.x * Mathf.Sqrt(1f - (y2 / 2f) - (z2 / 2f) + ((y2 * z2) / 3f));
        float y = point.y * Mathf.Sqrt(1f - (z2 / 2f) - (x2 / 2f) + ((z2 * x2) / 3f));
        float z = point.z * Mathf.Sqrt(1f - (x2 / 2f) - (y2 / 2f) + ((x2 * y2) / 3f));
        return new Vector3(x, y, z).normalized;
    }

    /*
     * Updates the chunk mesh on each frame if needed
     * The mesh is updated based on the planet's radius and detail level.
     */
    private void Update()
    {
        // gets the distance from the camera to the chunk center
        int detail;
        float distance = Vector3.Distance(Camera.main.transform.position, center + planet.transform.position);
        if (distance < LOD4Threshold)
            detail = LOD4Detail;
        else if (distance < LOD3Threshold)
            detail = LOD3Detail;
        else if (distance < LOD2Threshold)
            detail = LOD2Detail;
        else if (distance < LOD1Threshold)
            detail = LOD1Detail;
        else
            detail = 2;

        // generates the chunk mesh if the detail level has changed
        if (this.detail != detail)
        {
            this.detail = detail;
            generate();
        }
    }
}
