using UnityEngine;

public class Chunk
{
    // fields for the chunk
    private Vector3 origin;  // on the unit cube
    private Vector3 xAxis;  // magnitude is the size of the chunk on the unit cube
    private Vector3 yAxis;
    private ChunkManager chunkManager;
    private Vector3 center;  // the center of the chunk projected onto the planet
    private float size;  // adjusted size of the chunk based on the planet's radius
    private GameObject chunkGameObject;
    private Chunk[] subChunks = new Chunk[4];  // will be set if the chunk is split
    private float ratio => size / Vector3.Distance(Camera.main.transform.position, chunkManager.transform.position + center);

    /*
     * Constructor for Chunk.
     * Initializes the chunk with the given parameters.
     *
     * @param origin The origin point of the chunk.
     * @param xAxis The x-axis direction of the chunk.
     * @param yAxis The y-axis direction of the chunk.
     * @param chunkManager The manager responsible for handling chunks.
     */
    public Chunk(Vector3 origin, Vector3 xAxis, Vector3 yAxis, ChunkManager chunkManager)
    {
        this.origin = origin;
        this.xAxis = xAxis;
        this.yAxis = yAxis;
        this.chunkManager = chunkManager;
        center = project(origin + (.5f * xAxis) + (.5f * yAxis)) * chunkManager.body.radius;
        size = xAxis.magnitude * chunkManager.body.radius;
        chunkGameObject = chunkManager.requestChunk();
        generate();
    }

    /*
     * updates the chunks LOD (Level of Detail) based on the distance from the camera.
     * splits the chunk if it is too large and needs to be split, or merges it with its parent if it is small enough.
     */
    public void updateLOD()
    {
        // handle merging of chunks
        if (ratio < chunkManager.settings.LODThreshold) {
            tryMerge();
            return;
        }

        trySplit();
    }

    /*
     * Merges the child chunks into a single chunk if they are small enough.
     * If the chunk has already been merged, it does nothing.
     * Otherwise, it generates the chunk mesh and returns the sub-chunks to the chunk manager.
     */
    private void tryMerge()
    {
        // handles when chunk has already been merged
        if (chunkGameObject != null)
            return;

        // removes the sub-chunks
        chunkGameObject = chunkManager.requestChunk();
        generate();
        foreach (Chunk chunk in subChunks) {
            chunk.tryMerge();
            chunkManager.returnChunk(chunk.chunkGameObject);
        }
        subChunks = new Chunk[4];
    }

    /*
     * Splits the chunk into smaller chunks if it is too large.
     * Creates four sub-chunks and initializes them with the appropriate parameters.
     * to be called by leaf chunks that need to be split.
     */
    private void trySplit()
    {
        // handles when chunk does not need to be split
        if (size <= chunkManager.settings.maxChunkSize || ratio <= chunkManager.settings.LODThreshold)
            return;

        // creates the sub-chunks if they do not already exist
        if (chunkGameObject != null) {
            Vector3 splitXAxis = xAxis / 2f;
            Vector3 splitYAxis = yAxis / 2f;
            Vector3[] origins = new Vector3[] { Vector3.zero, splitXAxis, splitYAxis, splitXAxis + splitYAxis };

            // creates the sub-chunks and initializes them
            for (int i = 0; i < 4; i++) {
                subChunks[i] = new Chunk(origin + origins[i], splitXAxis, splitYAxis, chunkManager);
            }

            // removes the current chunk's game object and sets it inactive
            chunkManager.returnChunk(chunkGameObject);
            chunkGameObject = null;
        }

        // recursively updates the LOD of the sub-chunks
        foreach (Chunk chunk in subChunks) {
            chunk.updateLOD();
        }
    }

    /*
     * Generates the chunk mesh using the detail level
     * The chunk is generated by creating vertices and triangles
     */
    private void generate()
    {
        // creates variables to store the mesh data
        int resolution = chunkManager.settings.chunkResolution;
        Vector3[] vertices = new Vector3[resolution * resolution];
        int[] triangles = new int[(resolution - 1) * (resolution - 1) * 6];
        ComputeBuffer vertexBuffer = new ComputeBuffer(resolution * resolution, sizeof(float) * 3);
        ComputeBuffer triangleBuffer = new ComputeBuffer((resolution - 1) * (resolution - 1) * 6, sizeof(int));

        // starts the compute shader and returns the computed points
        vertexBuffer.SetData(vertices);
        triangleBuffer.SetData(triangles);
        setShaderParameters(vertexBuffer, triangleBuffer);
        int groups = Mathf.CeilToInt(resolution / 8f);
        chunkManager.terrainShader.Dispatch(0, groups, groups, 1);
        vertexBuffer.GetData(vertices);
        triangleBuffer.GetData(triangles);

        // sets the mesh data
        Mesh mesh = chunkGameObject.GetComponent<MeshFilter>().mesh;
        mesh.Clear();
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        vertexBuffer.Release();
        triangleBuffer.Release();
        mesh.RecalculateNormals();
    }

    /*
    * sets the shader parameters for the chunk 
    * 
    * @param vertexBuffer The compute buffer containing the vertices.
    * @param triangleBuffer The compute buffer containing the triangles.
    */
    private void setShaderParameters(ComputeBuffer vertexBuffer, ComputeBuffer triangleBuffer)
    {
        chunkManager.terrainShader.SetBuffer(0, "points", vertexBuffer);
        chunkManager.terrainShader.SetBuffer(0, "triangles", triangleBuffer);
        chunkManager.terrainShader.SetVector("origin", origin);
        chunkManager.terrainShader.SetVector("xAxis", xAxis);
        chunkManager.terrainShader.SetVector("yAxis", yAxis);
        chunkManager.terrainShader.SetFloat("radius", chunkManager.body.radius);
        chunkManager.terrainShader.SetInt("detail", chunkManager.settings.chunkResolution);
        chunkManager.terrainShader.SetInt("seed", chunkManager.body.seed);
    }

    /*
     * Projects a point on the unit cube to a point on the sphere using the
     * cube-to-sphere projection algorithm. This ensures that the vertices are
     * evenly distributed across the surface of the sphere.
     *
     * @param point The point on the unit cube to be projected.
     * @return The projected point on the sphere.
     */
    private Vector3 project(Vector3 point)
    {
        float x2 = point.x * point.x;
        float y2 = point.y * point.y;
        float z2 = point.z * point.z;
        float x = point.x * Mathf.Sqrt(1f - (y2 / 2f) - (z2 / 2f) + ((y2 * z2) / 3f));
        float y = point.y * Mathf.Sqrt(1f - (z2 / 2f) - (x2 / 2f) + ((z2 * x2) / 3f));
        float z = point.z * Mathf.Sqrt(1f - (x2 / 2f) - (y2 / 2f) + ((x2 * y2) / 3f));
        return new Vector3(x, y, z).normalized;
    }
}
